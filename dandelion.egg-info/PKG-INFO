Metadata-Version: 1.0
Name: dandelion
Version: 0.0.1
Summary: Extending Python builtin types
Home-page: https://github.com/hellerve/dandelion/
Author: Veit Heller
Author-email: veit@veitheller.de
License: MIT License
Description: 
        dandelion
        =============
        
        Yet another implementation of missing functions.
        
        Installation
        ------------
        
        ::
        
          pip install dandelion
        
        Usage
        -----
        
        For now only the datatypes have been implemented.
        Functional tooling will follow soon.
        
        Datatypes
        ---------
        
        All the functions are exhaustively documented with pydoc,
        all the parameters, the functions' time complexity (if applicable)
        and the return value are given. If the function does not return
        anything in the Python standard datatype, the datatype will return
        ``self`` to allow for chaining.
        
        .. code-block:: python
        
            from dandelion import *
        
            List([1]).append(2).extend([3, None, 4]).remove_empty() # => List([1, 2, 3, 4])
            List(range(10)).take(5) # => generator from 0 to 4
            List(range(10)).drop(5) # => generator from 5 to 9
            List(range(10)).nth(3) # => generator yielding 0, 3, 6 and 9 (lazily); works with any subclass of Iterable
            List(range(10)).reset(range(5)) # => List([0, 1, 2, 3, 4])
        
            Dict({1: 2, 3: 4}).reverse() # => Dict({2: 1, 4: 3})
            Dict({1: 2, 3: 4, 2: None}).remove_empty() # => Dict({1: 2, 3: 4})
            Dict({1: 2, 3: 4, None: "go away"}).remove_empty(filter_keys=True) # => Dict({1: 2, 3: 4})
            Dict({1: 2, 3: 4, 2: 3}).remove_empty(fun=lambda x: x!=2) # => Dict({1: 2, 3: 4})
            Dict({1: 2, 3: 4}).reduce(fun=acc, k, v: acc + k + v, acc=0) # => 10
            Dict({1: 2, 3: 4}).reduce(fun=acc, k, v: acc + (k, v), ) # => (1, 2, 3, 4)
        
            Set({1, 2, 3, 4}).remove_empty(fun=lambda x: x!=3) # => Set({1, 2, 4})
        
            # And now for something completely different
            Dict({
              "foo": List([1, 2, 3, Dict({"bar": "baz"})])
            }).get_in("foo", 3, "bar") # => "baz"
            Dict({
              "foo": List([1, 2, 3, Dict({"bar": "baz"})])
            }).get_in("foo", 100, "bar") # => None
            Dict({
              "foo": List([1, 2, 3, Dict({"bar": "baz"})])
            }).get_in("foo", 100, "bar", dflt="i am a default value") # => "i am a default value"
            Dict({
              "foo": List([1, 2, 3, Dict({"bar": "baz"})])
            }).update_in("foo", 1, "bar", to="update") # => Dict({"foo": List([1, 2, 3, Dict({"bar": "update"})])})
            # if you want to insert your own datatype, just inherit from dandelion.Collection
            # and implement get(key, dflt=None) and __setelem__
        
        Have fun!
        
Platform: UNKNOWN
